# LINUX 汇编学习  

## 内存屏障   
`barrier()`   
原型  
`#define barrier() __asm__ __volatile__("": : :"memory")  `  
\__volatitle_\_是防止编译器移动该指令的位置或者把它优化掉。"memory"，是提示编译器该指令对内存修改，防止使用某个寄存器中已经load 的内存的值。  

mb系列函数  
```c
#include <asm/system.h>  
"void rmb(void);"  
"void wmb(void);"  
"void mb(void);"
```
这些函数在已编译的指令流中插入硬件内存屏障，具体的插入方法是平台相关的。rmb（读内存屏障）保证了屏障之前的读操作一定会在后来的读操作执行之前完成。wmb保证写操作不会乱序，mb 指令保证了两者都不会。这些函数都是 barrier 函数的超集。解释一下：编译器或现在的处理器常会自作聪明地对指令序列进行一些处理，比如数据缓存，读写指令乱序执行等等。如果优化对象是普通内存，那么一般会提升性能而且不会产生逻辑错误。但如果对I/O 操作进行类似优化很可能造成致命错误。所以要使用内存屏障，以强制该语句前后的指令以正确的次序完成。
其实在指令序列中放一个wmb 的效果是使得指令执行到该处时，把所有缓存的数据写到该写的地方，同时使得wmb 前面的写指令一定会在wmb后面 的写指令之前执行。







[linux原子操作](https://blog.csdn.net/baidu_39511645/article/details/78301457 )